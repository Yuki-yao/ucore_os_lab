# Lab 2 实验报告

姚宇奇(2015011351)	计55

## 练习1：实现first-fit连续物理内存分配算法

### 实现思路

该算法的实现涉及default_init()，default_init_memmap()，default_alloc_pages()，default_free_pages()四个函数，以下分别进行讨论。

#### default_init()

将free_list初始化，并将nr_free（空闲页总数）初始化为0。原有代码已经实现该功能，未做修改。

#### default_init_memmap()

对某一特定内存块进行初始化的函数。具体实现思路为遍历该块中的所有页，将每个页的flags都初始化为可以引用的状态（PG_reserved清零，PG_property置位）；将引用数量(ref)和property记为0；将该页插入到free_list头部。最后，将该内存块的首页的property记为n（代表该内存块大小），并在nr_free上增加n。

#### default_alloc_pages()

分配空闲页的函数。首先确认剩余空闲页总数能够满足分配要求。接着按照first fit原则在free_list中从前向后遍历内存块，找到第一个大小满足要求的内存块后将需要占用的n页的flags依次置为占用状态(PG_reserved置位，PG_property清零)，并从free_list中摘除。如果该内存块页数比需求的大，则在摘除所有占用的页后将下一个空闲页设为剩余内存块的首页，并将property值减去n。最后，将nr_free减去n。

#### default_free_pages()

释放空闲页的函数。在free_list中从前向后遍历内存块，寻找按地址从小到大顺序排序时待释放内存块应在的位置。找到后，将内存块中的页依次将flags设置为占用状态，property和ref设为0，然后插入到相应位置中。块首页的property置为n。

接着将该内存块与前后空闲的内存块合并，以减少碎片。我的实现策略为先合并后一个内存块，然后尽量向前合并。首先检查下一空闲内存块地址是否与该内存块连续，若连续则直接将下一内存块的property加到该块上，并将下一内存块的property置零（不再为首页）。之后不用继续向后合并，因为默认执行尽量向前合并的算法。向前合并时，先考察前一页（而非内存块，因为上一块的大小是未知的）地址是否与当前块首页连续。如果连续，则一直向前遍历，直到找到前一内存块的首页(property不为0)。将首页的property加上当前块的property，然后将当前块的property清零，即完成合并。最后维护nr_free的值。

### 改进方向

由于采用双向链表的数据结构，对内存块的查找均为顺序遍历，效率较低。可以考虑改进数据结构，提高查找效率。

## 练习2：实现寻找虚拟地址对应的页表项

### 实现思路

先根据虚拟地址中的页目录项索引查找到对应的页目录项。若该项存在则直接根据虚拟地址中的页表项索引信息在对应页表中找到页表项；否则，如果允许建立新的页表，则调用物理内存分配函数新建一页填入对应页目录项，并将相应权限位置位。

### 页目录项与页表项的组成

页目录项PDE由页表起始地址、PTE_U（用户态是否可读）、PTE_W（物理内存页是否可写）、PTE_P（物理内存页是否存在）组成。潜在用处为作为一级页表项，存储了所有二级页表的物理地址信息。

页表项PTE由该页物理地址的前20位、PTE_P、PTE_W组成。潜在用处为存储所有页的物理信息，提供逻辑地址到物理地址的最后一级映射。

### 页访问异常的硬件处理

首先是针对一般异常必要的硬件处理工作，即在当前内核栈中保存现场；接着，CPU将对应的中断服务例程地址加载到CS和EIP寄存器中，将引起异常的线性地址装载到CR2寄存器中，给出出错码，然后开始执行中断服务例程。

## 练习3：释放某虚地址所在的页并取消对应二级页表项的映射

### 实现思路

首先判断该页表项是否存在。如果存在，那么将对应页的引用减一，如果已经没有引用则调用释放该页的函数；然后将页表项清空，最后刷新TLB。

### pages的项与页目录项、页表项的关系

每一个有效的页目录项→页表项的索引最终都会映射到pages中的某一项上去。事实上，页目录项或页表项的前20位完成了这一映射。

### 虚拟地址与物理地址相等的情况

注意到pmm.h对PADDR和KADDR的宏定义中，物理地址和虚拟地址间有偏移量KERNBASE。将memlayout.h中该偏移量的值从0xc0000000改为0x0即可。

## 与参考答案的区别

我的答案与参考答案的区别主要体现在练习1上。在default_alloc_pages中，我采用Page*而非list_entry_t作为变量进行遍历，并且在遍历中对每一页都进行了重设。在default_free_pages中，我在依次将空闲页插入free_list的同时进行了flags的重置，并且在向前合并的算法实现中采用了更加易懂的循环实现方式。

## 知识点

- 练习1：

  本实验中知识点：first-fit分配算法，页碎片的简单管理

  对应OS中知识点：动态分区分配策略

  相比之下，OS中的知识点更复杂、更全面，但实验中的算法更具体，实践性强。

- 练习2、3：

  本实验中知识点：多级页表的查找与新建页、多级页表中页的释放、虚拟地址与逻辑地址的映射

  对应OS中知识点：页式存储管理，多级页表

  本实验中的知识点设计到的细节处理更多，且与之前实现的页分配算法结合，综合性更强。OS课上的知识点更系统化。