# Lab8 Report

姚宇奇(2015011351)	计55

## 练习1

### 打开文件的处理流程

阅读实验指导书和相关代码可以知道，ucore的文件系统自上而下分为四层结构，分别是通用文件系统访问接口层、文件系统抽象层、Simple FS文件系统层和外设接口层。用户对文件系统的任何一种访问的处理过程都依次由这四层进行处理，即先通过访问接口层进入文件系统内部，再由抽象层把访问请求转发给某一个具体的文件系统，接着由具体文件系统将请求处理成对磁盘上block的处理请求，最后由外设接口层通过磁盘驱动例程完成具体磁盘操作。

具体到打开某一文件的操作，处理流程如下：

1. 通用接口访问层：调用如下用户态函数：open->sys_open->syscall，通过系统调用进入内核态，然后调用sys_open内核处理函数，进而调用内核函数sysfile_open，将文件路径拷贝至内核空间的path中，进入抽象层处理。
2. 文件系统抽象层：调用file_open函数，分配一个空闲的file结构的变量，这个变量在当前进程打开文件数组中的索引就是最终要返回的文件描述符；然后进一步调用vfs_open函数，这个函数先通过vfs_lookup找到path对应文件的索引节点(inode)，然后调用vop_open函数打开了文件。该函数执行完毕后，返回到file_open函数中，函数将file的node指针指向vfs_open得到的node，然后返回fd。顺着调用链一路返回，最终完成打开文件操作。
3. SFS文件系统层：上一步中vfs_lookup函数是通过先找到根目录对应的inode，再调用vop_lookup函数来找到目标文件的索引节点的。该函数在SFS文件系统中的实现就是sfs_lookup函数。该函数接受根节点和文件路径，然后将寻找到的目标文件节点存储在node_store中。具体处理流程为：以'/'为分隔符分解path获得各子目录，然后循环调用sfs_lookup_once查找各子节点，最终找到目标文件节点。

### sfs_io_noblock函数的实现

本练习要求补全sfs_io_noblock函数中读/写文件数据部分的代码。该部分代码的执行流程可以分为三步：

1. 如果开始读写的位置没有按块对齐，则先读/写到第一个块结束的位置。是否对齐是通过对blkoff按照块大小SFS_BLKSIZE取模来判断。求出要读写的空间大小后，用sfs_bmap_load_nolock函数计算出要读写的块的实际编号，再通过sfs_buf_op函数指针对该块进行读写操作。操作结束后，更新读写总长度alen、buf指针位置、下一块的逻辑编号blkno和剩余块数量nblks。
2. 进行整块读写，直到剩余要读写的内容不足一块为止。与上一步类似，先换算出下一块的实际编号，然后通过sfs_block_op函数指针进行整块读写，并更新相关变量。如此循环直至nblks为0。
3. 读写剩余部分。与第一步类似，只是结束读写后只需要更新alen。

### UNIX的PIPE机制的设计方案

管道时进程间通信的手段之一。对管道的操作要通过对两个已经打开的文件进行，这两个文件即代表了管道的两端。管道可以分为两种：无名管道（存在与父子进程或兄弟进程之间）和命名管道（任意两个进程之间可用，在文件系统中有实际存在的节点）。管道的本质是一个FIFO的缓冲区，可以从管道的一段向其中写入信息，也可以从另一端读取信息，但读写操作不可以同时进行。

在具体实现中，管道并不需要设计单独的数据结构，而可以借助file结构和VFS系统中的索引接点inode。实现方法为将两个file结构指向同一个临时的VFS索引节点，并将该节点指向一个物理页面。这两个file结构的文件操作例程地址分别定义为管道写操作和管道读操作。这样，就通过原先的文件系统结构实现了管道的操作。

管道执行写操作时，需要首先检查inode中的信息，确保内存没有被读程序锁定且内存中有足够空间写入相应内容。否则，写入进程休眠在VFS索引节点的等待队列中，由调度器调度其他进程执行，直到内存满足条件时再将其唤醒。写入过程中，内存需要被锁定，直到写入完毕后再释放。读操作与之类似，但是遇到内存被写进程锁定或无数据时可以直接返回错误，不必进入睡眠。

当所有进程完成了管道操作后，该管道的索引节点被丢弃，相应内存空间被释放。

## 练习2

### 基于文件系统的执行程序机制的实现

本实验要求完善proc.c中的alloc_proc函数，do_fork函数和load_icode函数，以实现执行程序机制。对于alloc_proc函数，只需要将proc_struct中新的filesp成员初始化为空即可。对于do_fork函数，只需要在初始化内核栈之后调用copy_files函数将fs成员复制到子进程即可。下面重点描述load_icode函数的实现思路。

首先检查用户栈传入参数个数是否符合规范，之后：

1. 为新进程建立新的mm结构：通过调用mm_create函数实现。
2. 建立新的页目录，并将mm->pgdir设为页目录的虚拟地址：通过setup_pgdir(mm)实现。
3. 将程序内容从文件加载至内存：
   1. 读取并解析ELF文件头和每个程序段头：声明相应变量，并利用load_icode_read函数从文件中读出相应信息。
   2. 为每个程序段建立vma：通过调用mm_map函数实现。
   3. 为TEXT/DATA段逐页分配内存，并利用load_icode_read函数从文件中读取数据到内存中。
   4. 为BSS段逐页分配内存，并将内存初始化为空。
4. 用mm_map函数设置好用户栈。
5. 用预定义的lcr3宏来设置新进程的mm、cr3、pgdir。
6. 将所有参数解析出来存入uargv中，然后计算新的栈顶stacktop。
7. 设置进程的中断帧，过程基本与之前lab的实现相同。
8. 错误处理部分。

### UNIX的硬链接和软链接机制设计方案

硬链接是指不同文件名对应的inode相同的情况。阅读代码可以发现，vfs.h中预留了硬链接接口`int vfs_link(char *old_path, char *new_path)`。具体实现思路如下：为new_path创建一个新的file，然后将它的node成员指向old_path对应file的node成员，并将该inode的引用计数(ref_count)加一即可。unlink时，需要将引用计数减一。

软链接（符号链接）是指新文件的inode与旧文件不同，但文件内容为旧文件路径的情况。系统读取该文件时，会自动将访问者导向旧文件。vfs.h中也预留了接口`int vfs_symlink(char *old_path, char *new_path)`。具体实现思路如下：为new_path创建一个新的文件，inode也与旧文件不同，然后将old_path存入新文件的内容中，并将新文件inode的类型指定为SFS_TYPE_LINK（ucore中已预留了这个定义）。除此之外，需要对SFS_TYPE_LINK类型的inode对应文件的一系列操作的实现进行相应的修改。unlink时的情况与删除普通文件类似。

## 与参考答案的区别

本次实验我的实现与参考答案相比没有语义上的区别，只是个别细节的处理有一些不同。

## 知识点比较

本实验涉及的知识点：ucore文件系统的基本结构及相关数据结构，VFS，SFS，ucore读写文件的基本流程，ucore执行程序的基本流程，磁盘的读写操作。

OS课程知识点：文件系统的基本概念（存储结构，基本操作），虚拟文件系统，文件缓存，空闲空间管理。

## 实验小结

本次实验的编码量较之前几次实验都要多，给出的提示相对也更少，涉及的知识点相对更加综合。通过动手实现全部练习后，我对OS的文件系统的认识有了很大提升，对UNIX内核系统的底层实现有了更多的了解。

至此，本学期8个操作系统的实验也已经全部完成。在本学期OS实验的过程中，我在老师、助教和实验指导书的帮助下，以补充代码的形式将一个已经实现基本框架的教学操作系统加以完善，从而在实践过程中巩固了课堂上学到的知识，同时遭遇了各种各样其他方面的问题并尝试加以解决，也得到了很多课程知识点以外的收获。当然，在实验过程中我也发现，现有的实验指导书还有很多信息错漏之处，而课程本身的信息发布平台过多过乱也反而造成了信息庞杂、沟通不及时的问题，相信OS课程组的老师和助教们一定能够吸取这些经验，进一步提升教学质量。

感谢助教和老师们的辛勤付出，衷心祝愿OS课程越办越好！