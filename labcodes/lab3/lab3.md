# Lab3 Report

姚宇奇(2015011351)	计55

## 练习1

### 实现思路

首先利用上次实验完成的get_pte()函数，根据mm提供的页目录基址和出错位置的虚拟地址查找页表项，并规定在页表不存在时新建一个页表。如果目标页帧不存在（此时页表项全为0），则在内存中分配一个新页并建立映射，这些操作通过调用函数pgdir_alloc_page()完成。

### 页目录项(PDE)和页表项(PTE)中的组成部分对ucore实现页替换算法的潜在用处

PDE和PTE的地址部分为各级表项之间的跳转提供了目标。页目录项的标志位在get_pte()函数中用来判断页表是否存在，页表项的标志位则在do_pgfault()中用来判断页帧是否存在。因此，页目录项中存储的页表信息为页替换提供了目标，页表项中存储的页帧信息则称为页替换时采用不同策略的依据。

### 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，硬件需要做哪些事？

首先CPU将引发异常的线性地址装入寄存器CR2中，并将出错码存入中断栈中，以告知软件页访问异常的类型。之后中断服务例程执行do_pgfault()函数来进行软件上的异常处理。

##练习2

### 实现思路

这部分的内容涉及以下三个函数：do_pgfault(), _fifo_map_swappable(), _fifo_swap_out_victim()。以下分别进行说明。

#### do_pgfault()

代码实现是练习1的延续。在练习1中目标页帧存在的情况下，对应的情景是相应的物理页帧不在内存中，而是在swap分区或磁盘上。此时如果已经完成了交换分区的初始化，则调用swap_in()函数在内存中分配一个新页，并将磁盘中相应的内容读取到该页上。接着通过page_insert()函数为该页和给出的虚拟地址构建映射关系，再通过swap_map_swappable将该页设置为可交换状态，最后将虚拟地址存在该页的pra_vaddr成员中。

#### _fifo_map_swappable()

只需补充一行将最近加入的一页插到pra_list的头部（实际为pra_list_head的后一个元素）的代码`list_add(head, entry)`即可。

#### _fifo_swap_out_victim()

需要根据FIFO的原则选择最早进入列表的页准备换出。具体实现为通过定位到循环链表头部的前一项来确定最早加入的页，然后通过list_del()方法将该项从列表中移除，最后将ptr_page指针指向该页即可。